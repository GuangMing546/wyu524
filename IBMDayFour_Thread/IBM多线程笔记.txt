1.线程（一般指多线程）：一个程序可以包括多个子任务，可串/并行，每个子任务可以称为一个线程。
如果一个子任务阻塞，程序可以将CPU调度另外一个子任务进行工作。
这样CPU还是保留在本程序中，而不是被调度到别的程序(进程)去。这样，提高本程序所获得CPU时间和利
用率。
◼ 线程是比进程更小的执行单位，线程是进程的基础之上进行进一步的划分。
◼ 所谓的多线程是指一个进程在执行过程中可以产生多个更小的程序单元，称为线程，
◼ 这些线程可以同时存在，同时运行。
◼ 在Java中，一个应用程序对应着一个JVM实例（也称为JVM进程），
◼ 一般来说名字默认为java.exe或者javaw.exe。 ◼ Java采用的是单线程编程模型，即在我们自己的程序中如果没有主动创建线程的话，只会创建一个线程，通常称为主线
程。但是要注意，虽然只有一个线程来执行任务，不代表JVM中只有一个线程，JVM实例在创建的时候，同时会创建很
多其他的线程（比如垃圾收集器线程）

2.◼ 多线程的产生并不是因为发明了多核CPU甚至现在有多个CPU+多核的硬件，也不是因为多线程CPU运行
效率比单线程高。单从CPU的运行效率上考虑，单任务进程及单线程效率是最高的，因为CPU没有任何进
程及线程的切换开销。
◼ 多线程与单线程的区别
◼ 多线程的出现主要为了解决IO设备的读写速度往往比CPU的处理速度慢造成的单线程程序运行阻塞问题，
一个极端的例子就是如果你需要用户在键盘上输入一个数据，当用户没有输入前，单线程程序就阻塞了，
多线程程序就可以放个音乐或继续干一些程序中除了键盘输入外的工作，因此，多线程能提高因程序由于
等待某个资源阻塞时其他资源的利用率（是利用率不是效率）。
◼ 因此多线程与单线程的最大区别，多线程程序能在等待某个IO操作时，继续完成非这个IO的其他工作，有
利于提高完成整个任务的效果和速度。此外，多线程程序与单线程程序对程序设计也有不同的流程和结构，
多线程需要考虑对静态变量等资源的操作互锁及程序执行的同步问题。

3.◼ 多线程就一定比单线程快？
不一定。因为，存在线程创建和上下文切换的时间开销。

4.◼ 线程实现方式1:通过继承Thread类实现
◼ 线程实现方式2：通过实现Runnable接口
◼ 线程实现方式3：通过实现Callable接口
实现线程除了以上三种还会不会有其他的方式呢？
答案是:还有很重要的方式，那就是项目中经常用到的线程池来创建线程，线程池
我们后面的课程会详细讲到的。
----------------------------------------------------------------------------------------------------------
5.◼ 线程池
事先创建若干个可执行的线程放入一个池（容器）中，需要的时候从池中获取线程，不用自行创建，使用完
毕不需要销毁线程而是放回池中，从而减少创建和销毁线程对象的开销。
◼ 线程池的作用
◼ 减少资源的开销。
◼ 减少了每次创建线程、销毁线程的开销。
◼ 提高响应速度。 ◼ 每次请求到来时，由于线程的创建已经完成，故可以直接执行任务，因此提高了响应速度。
◼ 提高线程的可管理性。 ◼ 线程是一种稀缺资源，若不加以限制，不仅会占用大量资源，而且会影响系统的稳定性。
◼ 因此，线程池可以对线程的创建与停止、线程数量等等因素加以控制，使得线程在一种可控的范围内运行，
不仅能保证系统稳定运行，而且方便性能调优。

6.ExecutorService类
void shutdown() 
          启动一次顺序关闭，执行以前提交的任务，但不接受新任务。 
 List<Runnable>	shutdownNow() 
          试图停止所有正在执行的活动任务，暂停处理正在等待的任务，并返回等待执行的任务列表。 
<T> Future<T> 	submit(Callable<T> task) 
          提交一个返回值的任务用于执行，返回一个表示任务的未决结果的 Future。 
 Future<?>	submit(Runnable task) 
          提交一个 Runnable 任务用于执行，并返回一个表示该任务的 Future。 
<T> Future<T> 	submit(Runnable task, T result) 
          提交一个 Runnable 任务用于执行，并返回一个表示该任务的 Future。 
 void execute(Runnable command) 
          在未来某个时间执行给定的命令 

6.JDK自带的线程池大家可以根据场景选用，在阿里的开发手册中要求在实现线程池时明确的
	通过ThreadPoolExecutor去自行创建，并要求使用有界队列作为线程池的工作队列
	同时对线程池允许创建的最大线程数也要限制，因为以上几个线程池：1.SingleThreadExecutor，FixedThreadPool，CachedThreadPool
							        2.ScheduledThreadPool
	都存在对资源的使用没有限制的问题（任务队列：无边界队列），所以大家还是根据实际情况去自行创建吧

7.◼ ThreadPoolExecutor创建线程池
	Executors类提供了4个常见的创建方法：
		◼ newCachedThreadPool
		◼ newFixedThreadPool
		◼ newSingleThreadExecutor
		◼ newScheduledThreadPool
这些方法最终都是通过ThreadPoolExecutor类来完成的，当有一些场景需要更细粒度的控制的线程池，可
以使用ThreadPoolExecutor方法创建线程池。
◼ Java中已经提供了创建线程池的一个类：Executor，
而我们创建时，一般使用它的子类：ThreadPoolExecutor，
ThreadPoolExecutor是Executor接口的一个重要的实现类，
是线程池的具体实现，用来执行被提交的任务。

8.public ThreadPoolExecutor(int corePoolSize, 
			int maximumPoolSize, 
			long keepAliveTime, 
			TimeUnit unit, 
			BlockingQueue<Runnable> workQueue, 
			ThreadFactory threadFactory, 
			RejectedExecutionHandler handler)
这是其中最重要的一个构造方法，这个方法决定了创建出来的线程池的各种属性，
ThreadPoolExecutor创建线程池的参数
	◼ corePoolSize:
		线程池中的核心线程数量，即使是在没有用的时候，也不会被回收。
	◼ maximumPoolSize
		线程池中可以容纳的最大线程的数量。
 	◼ keepAliveTime
		线程池中除了核心线程之外的其他的最长可以保留的时间，因为在线程池中，除了核心线程即使在无任务的情况下也不能被清除，
		其余的都是有存活时间的，意思就是非核心线程可以保留的最长的空闲时间。
 	◼ util
		计算这个时间的一个单位。
 	◼ workQueue
		等待队列，任务可以储存在任务队列中等待被执行，执行的是FIFIO原则（先进先出）。
	◼ threadFactory
		创建线程的线程工厂。
 	◼ handler
		一种拒绝策略，我们可以在任务满了之后，拒绝执行某些任务

9.线程池的执行流程：1.使用者提交任务
		2.线程池：判断核心线程池是否已满，没满就用核心线程来执行任务，满了就下一步判断任务队列是否已满
			没满就将任务存储在队列里面，满了就下一步判断线程池是否已满
			没满就创建线程执行任务，满了就按照策略处理无法执行的任务

10.◼ 线程池配置合理线程数（了解）
	◼ 合理线程数配置之CPU密集型
		CPU密集型任务配置尽可能少的线程数量:一般公式：CPU核数+1个线程的线程池
	◼ 合理线程数配置之IO密集型
		方法一：由于IO密集型任务线程并不是一直在执行任务，则应配置尽可能多的线程，如CPU核数*2
		方法二：IO密集型时，大部分线程都阻塞，故需要多配置线程数：
			参考公式：CPU核数/（1-阻系数）
			比如8核CPU：8/(1．0．9)=80个线程数
			阻塞系数在0.8~0.9之间
	◼ 压力测试/性能测试/冒烟测试
--------------------------------------------------------------------------------------------------------------
11.线程间的通信：
	◼ 线程间的常用通信方式
	◼ synchronized + wait + notifyAll + 条件
	◼ Lock + Condition + 条件
	◼ Semaphore
	◼ CountDownLatch
	◼ Cyclicbarrier
	◼ Exchanger
	◼ sleep、join、yield
12.◼ 线程通信一 ：synchronized + wait + notifyAll + 条件 小结: 
		wait( )，notify( )，notifyAll( )
	◼ wait( )，notify( )，notifyAll( )都不属于Thread类，而是属于Object基础类，也就是每个对象都有wait( )，
		notify( )，notifyAll( ) 的功能，因为每个对象都有锁，锁是每个对象的基础。
	◼ 当想要调用wait( )进行线程等待时，必须要取得这个锁对象的控制权（对象监视器），一般是放到
		synchronized(obj)代码中。
	◼ 在while循环里而不是if语句下使用wait，这样，会在线程暂停恢复后都检查wait的条件，并在条件实际上
		并未改变的情况下处理唤醒通知。
	◼ 调用obj.wait( )释放了obj的锁，否则其他线程也无法获得obj的锁，也就无法在
		synchronized(obj){ obj.notify() } 代码段内唤醒。
	◼ notify( )方法只会通知等待队列中的第一个相关线程
	◼ notifyAll( )通知所有等待该竞争资源的线程（也不会按照线程的优先级来执行）
13.◼ Lock + Condition -小结：
	◼ ReentrantLock 在Java也是一个基础的锁，ReentrantLock 实现Lock接口提供一系列的基础函数(比如说lock()和
		unlock()方法),开发人员可以灵活的是应用函数满足各种复杂多变应用场景。
		ReentrantLock主要利用CAS+AQS队列来实现。它支持公平锁和非公平锁，两者的实现类似。
	◼ CAS：Compare and Swap，比较并交换。在Java中，CAS主要是由sun.misc.Unsafe这个类通过JNI调用CPU底层指令实现。
	◼ AQS：AbstractQueuedSynchronizer的简称。是一个用于构建锁和同步容器的框架。事实上concurrent包内许多类都是基于
		AQS构建，例如ReentrantLock，Semaphore，CountDownLatch，ReentrantReadWriteLock，FutureTask等。AQS解决了在
		实现同步容器时设计的大量细节问题。
	⚫ ReentrantLock.Condition的线程通信：
		ReentrantLock.Condition是在粒度和性能上都优于Object的notify()、wait()、notifyAll()线程通信的方式。
		Condition中通信方法相对Object的通信在粒度上是粒度更细化，表现在一个Lock对象上引入多个Condition监视器、
		通信方法中除了和Object对应的三个基本函数外，更是新增了线程中断、阻塞超时的函数；
		Condition中通信方法相对Object的通信在性能上更高效，性能的优化表现在ReentrantLock比较synchronized的优化 。
	注意：在使用ReentrantLock.Condition中使用signal()、await()、signalAll()方法，不能和Object的notify()、wait()、
	notifyAll()方法混用，否则抛出异常。
---------------------------------------------------------------
18.◼ 多线程的同步总结
	◼ 同步方法实现线程同步
	◼ 同步代码块实现线程同步
	◼ 使用特殊域变量(volatile)实现线程同步
	◼ 使用重入锁实现线程同步
	◼ 使用局部变量实现线程同步（ThreadLocal）
19.ThreadLocal与synchronized对比
	相同点： ◼ ThreadLocal和Synchonized都用于解决多线程并发访问。
	不同点： ◼ Synchronized关键字主要解决多线程共享数据同步问题，ThreadLocal使用场合主要解决多线程中数据因并发产生不一致问题；
	◼ Synchronized是利用锁的机制，使变量或代码块在某一时该只能被一个线程访问。而ThreadLocal为每一个线程都提供
		了变量的副本，使得每个线程在某一时间访问到的并不是同一个对象，这样就隔离了多个线程对数据的数据共享。而
		Synchronized却正好相反，它用于在多个线程间通信时能够获得数据共享；
	◼ Synchronized用于线程间的数据共享，而ThreadLocal则用于线程间的数据隔离；
	◼ ThreadLocal本质上不是Thread ，而是线程局部变量(ThreadLocal)其实的功用非常简单，就是为每一个使用该变量的
		线程都提供一个变量值的副本，是Java中一种较为特殊的线程绑定机制，是每一个线程都可以独立地改变自己的副本，
		而不会和其它线程的副本冲突。
	◼ ThreadLocal维护变量副本：在ThreadLocal类中有一个Map，用于存储每一个线程的变量的副本。
	◼ 概括起来说，对于多线程资源共享的问题，同步机制采用了“以时间换空间”的方式，而ThreadLocal采用了“以空间
		换时间”的方式。前者仅提供一份变量，让不同的线程排队访问，而后者为每一个线程都提供了一份变量，因此可以同
		时访问而互不影响
20.◼ 程序中使用局部变量(ThreadLocal)实现线程同步
	如果使用ThreadLocal管理变量，则每一个使用该变量的线程都获得该变量的副本，副本之间相互独立，这样每一个线程
	都可以随意修改自己的变量副本，而不会对其他线程产生影响。
ThreadLocal与同步机制的比较
	◼ ThreadLocal与同步机制都是为了解决多线程中相同变量的访问冲突问题
		◼ 前者采用以"空间换时间"的方法，后者采用以"时间换空间"的方式
--------------------------------------------------------------------------------------------
21.高并发与多线程
	◼ 什么是高并发？
		高并发（High Concurrency）是一种系统运行过程中遇到的一种“短时间内遇到大量操作请求”的情况，主要发生在web
		系统集中大量访问收到大量请求（例如：12306的抢票情况；天猫双十一活动）。该情况的发生会导致系统在这段时间内
		执行大量操作，例如对资源的请求、数据库的操作等。
	◼ 高并发的常用处理指标
		◼ 响应时间（Response Time）
			系统对请求做出响应的时间。例如系统处理一个HTTP请求需要200ms，这个200ms就是系统的响应时间
		◼ 吞吐量（Throughput）
			单位时间内处理的请求数量。
		◼ 每秒查询率QPS（Query Per Second）
			每秒响应请求数。在互联网领域，这个指标和吞吐量区分的没有这么明显。
		◼ 并发用户数
			同时承载正常使用系统功能的用户数量。例如一个即时通讯系统，同时在线量一定程度上代表了系统的并发用户数。
22.高并发和多线程的关系和区别
	◼ 高并发和多线程”总是被被一起提起，给人的感觉好像他们相等，其实 高并发 不等于 多线程
	◼ 多线程是完成任务的一种方法，高并发是系统运行的一种状态，通过多线程有助于系统承受高并发的状态的实现。
	◼ 多线程是JAVA的特性，因为现在cpu都是多核多线程的，可以同时执行几个任务，为了提高JVM的执行效率，JAVA提
		供了这种多线程的机制，以增强数据处理效率。多线程对应的是CPU ，高并发对应的是访问请求，可以用单线程处理
		所有访问请求，也可以用多线程同时处理访问请求。
	◼ 在过去单CPU时代，单任务在一个时间点只能执行单一程序。之后发展到多任务阶段，计算机能在同一时间点并行执
		行多任务或多进程。虽然并不是真正意义上的“同一时间点”，而是多个任务或进程共享一个CPU，并交由操作系统
		来完成多任务间对CPU的运行切换，以使得每个任务都有机会获得一定的时间片运行。
	◼ 后来发展到多线程技术，使得在一个程序内部能拥有多个线程并行执行。一个线程的执行可以被认为是一个CPU在执
		行该程序。当一个程序运行在多线程下，就好像有多个CPU在同时执行该程序。总之，多线程即可以这么理解：多线
		程是处理高并发的一种编程方法，即并发需要用多线程实现。
高并发和多线程的关系和区别
	◼ 高并发不是JAVA的专有的东西，是语言无关的广义的，为提供更好互联网服务而提出的概念。
		典型的场景，例如：12306抢火车票，天猫双十一秒杀活动等,
		该情况的发生会导致系统在这段时间内执行大量操作，例如对资源的请求，数据库的操作等,
		如果高并发处理不好，不仅仅降低了用户的体验度(请求响应时间过长)，
		同时可能导致系统宕机，严重的甚至导致OOM异常，系统停止工作等。
	◼ 如果要想系统能够适应高并发状态，
		则需要从各个方面进行系统优化，包括，硬件、网络、系统架构、开发语言的选取、数据结构的运用、算法优化、数
		据库优化等……，而多线程只是其中解决方法之一。

23.怎样提高系统的高并发能力？
	◼ 静态资源结合CDN来解决图片文件等访问
	◼ 分布式缓存：redis、memcached等。
	◼ 消息队列中间件：RabbitMQ,activeMQ等，解决大量消息的异步处理能力。
	◼ 应用拆分:一个工程被拆分为多个工程部署，利用微服务技术解决多工程之间的通信。
	◼ 数据库垂直拆分和水平拆分(分库分表)等。
	◼ 数据库读写分离，解决大数据的查询问题。
	◼ 利用nosql ，例如mongoDB配合mysql组合使用。
	◼ 建立大数据访问情况下的服务降级以及限流机制等。








